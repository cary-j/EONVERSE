/// <reference types="t" />
/// <reference types="@rbxts/types" />
/// <reference types="@rbxts/types" />
/// <reference types="maid" />
/// <reference types="signal" />
/// <reference types="@rbxts/compiler-types" />
/// <reference types="@rbxts/types" />
/// <reference types="@rbxts/types" />
/// <reference types="@rbxts/compiler-types" />
import Maid from "@rbxts/maid";
import { t } from "@rbxts/t";
import { OnInit, OnStart } from "@flamework/core";
import Signal from "@rbxts/signal";
type Constructor<T = unknown> = new (...args: never[]) => T;
export interface ComponentConfig {
    /**
     * The CollectionService tag this component is associated with.
     */
    tag?: string;
    /**
     * Override guards for specified attributes.
     */
    attributes?: {
        [key: string]: t.check<unknown>;
    };
    /**
     * By default, Flamework will not construct components which do not pass the specified attribute guards.
     * You can specify default values which Flamework will use instead of cancelling the component's construction.
     */
    defaults?: {
        [key: string]: unknown;
    };
    /**
     * Overrides the guard generated by Flamework to validate instance trees.
     */
    instanceGuard?: t.check<unknown>;
    /**
     * Should this instance be ignored?
     *
     * This property differs from `instanceGuard` because it cancels the CollectionService event,
     * whereas `instanceGuard` may continue to fire, along with other checks.
     */
    predicate?: (instance: Instance) => boolean;
    /**
     * Should this component watch for changes to attributes?
     *
     * This will disable `onAttributeChanged` events in the component, as well.
     */
    refreshAttributes?: boolean;
    /**
     * Specifies where components can be constructed via CollectionService.
     * This has higher priority than `ancestorBlacklist`, including the default blacklist.
     *
     * This has the same behavior as a predicate.
     */
    ancestorWhitelist?: Instance[];
    /**
     * Specifies where components can not be constructed via CollectionService.
     * Defaults to ServerStorage and ReplicatedStorage.
     *
     * This has the same behavior as a predicate.
     */
    ancestorBlacklist?: Instance[];
    /**
     * Flamework will warn whenever a component isn't able to be created while watching for CollectionService tags,
     * this allows you to adjust how long until that warning appears.
     *
     * Defaults to 5, set to 0 to disable.
     */
    warningTimeout?: number;
}
/**
 * Register a class as a Component.
 *
 * @metadata flamework:implements flamework:parameters injectable
 */
export declare const Component: ((opts?: ComponentConfig | undefined) => ((ctor: defined) => never) & {
    _flamework_Decorator: never;
}) & {
    _flamework_Parameters: [opts?: ComponentConfig | undefined];
};
export declare class BaseComponent<A = {}, I extends Instance = Instance> {
    /**
     * A maid that will be destroyed when the component is.
     */
    maid: Maid;
    /**
     * Attributes attached to this instance.
     */
    attributes: A;
    /**
     * The instance this component is attached to.
     * This should only be called in a component lifecycle event.
     */
    instance: I;
    setInstance(instance: I, attributes: unknown): void;
    setAttribute<T extends keyof A>(key: T, value: A[T], postfix?: boolean): A[T];
    /** @hidden */
    _attributeChangeHandlers: Map<string, Signal<(newValue: unknown, oldValue: unknown) => void, false>>;
    /**
     * Connect a callback to the change of a specific attribute.
     * @param name The name of the attribute
     * @param cb The callback
     */
    onAttributeChanged<K extends keyof A>(name: K, cb: (newValue: A[K], oldValue: A[K]) => void): RBXScriptConnection;
    /**
     * Destroys this component instance.
     */
    destroy(): void;
}
/**
 * This class is responsible for loading and managing
 * all components in the game.
 */
export declare class Components implements OnInit, OnStart {
    private components;
    private classParentCache;
    private activeComponents;
    private activeInheritedComponents;
    private reverseComponentsMapping;
    private trackers;
    private componentWaiters;
    onInit(): void;
    onStart(): void;
    private getComponentTracker;
    private getParentConstructor;
    private getOrderedParents;
    private getAttributeGuards;
    private getAttributes;
    private getConfigValue;
    private safeCall;
    private setupComponent;
    private getComponentFromSpecifier;
    private getIdFromSpecifier;
    private addIdMapping;
    private removeIdMapping;
    private canCreateComponentEager;
    private getDependencyResolutionOptions;
    /**
     * This returns the specified component associated with the instance.
     *
     * The specified type must be exact and not a lifecycle event or superclass. If you want to
     * query for lifecycle events or superclasses, you should use the `getComponents` method.
     */
    getComponent<T>(instance: Instance, componentSpecifier?: Constructor<T> | string): T | undefined;
    /**
     * This returns all components associated with the instance that extend or implement the specified type.
     *
     * For example, `getComponents<OnTick>` will retrieve all components that subscribe to the OnTick lifecycle event.
     */
    getComponents<T>(instance: Instance, componentSpecifier?: Constructor<T> | string): T[];
    /**
     * Adds the specified component to the instance.
     * The specified class must be exact and cannot be a lifecycle event or superclass.
     */
    addComponent<T>(instance: Instance, componentSpecifier?: Constructor<T> | string): T;
    /**
     * Removes the specified component from this instance.
     * The specified class must be exact and cannot be a lifecycle event or superclass.
     */
    removeComponent<T>(instance: Instance, componentSpecifier?: Constructor<T> | string): void;
    /**
     * This returns all components, across all instances, which extend or implement the specified type.
     *
     * For example, `getAllComponents<OnTick>` will retrieve all components that subscribe to the OnTick lifecycle event.
     */
    getAllComponents<T>(componentSpecifier?: Constructor<T> | string): T[];
    /**
     * This returns a promise which will fire when the specified component is added.
     * This will first call `getComponent` which means it can resolve instantly and will also
     * have the eager loading capabilities of `getComponent`.
     *
     * This only fires once and should be cancelled to avoid memory leaks if the Promise is discarded prior to being invoked.
     */
    waitForComponent<T>(instance: Instance, componentSpecifier?: Constructor<T> | string): Promise<T>;
}
export {};
