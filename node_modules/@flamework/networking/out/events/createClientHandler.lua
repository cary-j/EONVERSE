-- Compiled with roblox-ts v2.1.0
local TS = _G[script]
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
local fireNetworkHandler = TS.import(script, script.Parent.Parent, "handlers").fireNetworkHandler
local createMiddlewareProcessor = TS.import(script, script.Parent.Parent, "middleware", "createMiddlewareProcessor").createMiddlewareProcessor
local createClientMethod
local function createClientHandler(remotes, networkInfos, serverEvents, clientEvents, config, middlewareFactoryList)
	local handler = {}
	local bindables = {}
	local processors = {}
	local isSetup = {}
	for name in pairs(clientEvents) do
		local bindable = Instance.new("BindableEvent")
		bindables[name] = bindable
	end
	local setupRemote = function(name)
		local _name = name
		if isSetup[_name] ~= nil then
			return nil
		end
		local _name_1 = name
		isSetup[_name_1] = true
		local _remotes = remotes
		local _name_2 = name
		local remote = _remotes[_name_2]
		local _networkInfos = networkInfos
		local _name_3 = name
		local networkInfo = _networkInfos[_name_3]
		local _name_4 = name
		local middlewareProcessor = processors[_name_4]
		remote.OnClientEvent:Connect(function(...)
			local args = { ... }
			local guards = clientEvents[name]
			if not guards then
				return nil
			end
			if not config.disableClientGuards then
				local paramGuards = guards[1]
				local restGuard = guards[2]
				do
					local i = 0
					local _shouldIncrement = false
					while true do
						if _shouldIncrement then
							i += 1
						else
							_shouldIncrement = true
						end
						if not (i < math.max(#paramGuards, #args)) then
							break
						end
						local guard = paramGuards[i + 1] or restGuard
						if guard and not guard(args[i + 1]) then
							if config.warnOnInvalidGuards then
								warn("Server sent invalid argument for event '" .. (name .. ("' (arg #" .. (tostring(i) .. "):"))), args[i + 1])
							end
							fireNetworkHandler("onBadRequest", Players.LocalPlayer, networkInfo, i)
							return nil
						end
					end
				end
			end
			middlewareProcessor(nil, unpack(args))
		end)
	end
	for name, remote in remotes do
		local networkInfo = networkInfos[name]
		local _result = middlewareFactoryList
		if _result ~= nil then
			_result = _result[name]
		end
		local middlewareProcessor = createMiddlewareProcessor(_result, networkInfo, function(_, ...)
			local args = { ... }
			local _result_1 = bindables[name]
			if _result_1 ~= nil then
				_result_1 = _result_1:Fire(unpack(args))
			end
			return _result_1
		end)
		processors[name] = middlewareProcessor
		local _exp = function()
			return setupRemote(name)
		end
		local _result_1 = clientEvents[name]
		if _result_1 ~= nil then
			_result_1 = #_result_1
		end
		local _condition = _result_1
		if _condition == nil then
			_condition = 0
		end
		handler[name] = createClientMethod(_exp, remote, _condition, bindables[name], middlewareProcessor)
	end
	return handler
end
function createClientMethod(connect, remote, paramCount, bindable, process)
	local method = {
		fire = function(self, ...)
			local args = { ... }
			remote:FireServer(unpack(args))
		end,
		connect = function(self, callback, customGuards)
			local _bindable = bindable
			local _arg1 = "Event " .. (remote.Name .. " is not registered as a receiver.")
			assert(_bindable, _arg1)
			task.defer(connect)
			return bindable.Event:Connect(function(...)
				local args = { ... }
				if customGuards then
					do
						local i = 0
						local _shouldIncrement = false
						while true do
							if _shouldIncrement then
								i += 1
							else
								_shouldIncrement = true
							end
							if not (i < paramCount) then
								break
							end
							local guard = customGuards[i + 1]
							if guard ~= nil and not guard(args[i + 1]) then
								return nil
							end
						end
					end
				end
				return callback(unpack(args))
			end)
		end,
		predict = function(self, ...)
			local args = { ... }
			local _process = process
			local _arg1 = "Event " .. (remote.Name .. " does not have a middleware processor.")
			assert(_process, _arg1)
			process(nil, unpack(args))
		end,
	}
	setmetatable(method, {
		__call = function(method, ...)
			local args = { ... }
			method:fire(unpack(args))
		end,
	})
	return method
end
return {
	createClientHandler = createClientHandler,
}
