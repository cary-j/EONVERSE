-- Compiled with roblox-ts v2.1.0
local TS = _G[script]
local t = TS.import(script, TS.getModule(script, "@rbxts", "t").lib.ts).t
local _errors = TS.import(script, script.Parent, "errors")
local getFunctionError = _errors.getFunctionError
local NetworkingFunctionError = _errors.NetworkingFunctionError
local createMiddlewareProcessor = TS.import(script, script.Parent.Parent, "middleware", "createMiddlewareProcessor").createMiddlewareProcessor
local Skip = TS.import(script, script.Parent.Parent, "middleware", "skip").Skip
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
local fireNetworkHandler = TS.import(script, script.Parent.Parent, "handlers").fireNetworkHandler
local createClientMethod, getProcessResult
local function createClientHandler(serverRemotes, clientRemotes, networkInfos, serverEvents, clientEvents, config, middlewareFactoryList)
	local handler = {}
	local processors = {}
	local requestInfo = {
		nextId = 0,
		requests = {},
	}
	local function createMethod(name, networkInfo, remote)
		if handler[name] ~= nil then
			return nil
		end
		local _exp = (serverEvents[name] or clientEvents[name])[2]
		local _result = middlewareFactoryList
		if _result ~= nil then
			_result = _result[name]
		end
		local _condition = _result
		if _condition == nil then
			_condition = {}
		end
		handler[name] = createClientMethod(_exp, _condition, processors, networkInfo, requestInfo, name, remote, config)
	end
	for alias, remote in serverRemotes do
		local name = string.sub(alias, 3)
		local networkInfo = networkInfos[name]
		createMethod(name, networkInfo, remote)
		remote.OnClientEvent:Connect(function(id, processResult, result)
			if not t.number(id) then
				return nil
			end
			local _requests = requestInfo.requests
			local _id = id
			local request = _requests[_id]
			local _requests_1 = requestInfo.requests
			local _id_1 = id
			_requests_1[_id_1] = nil
			if request then
				request(result, getFunctionError(processResult))
			end
		end)
	end
	for alias, remote in clientRemotes do
		-- invoke callback
		local name = string.sub(alias, 3)
		local networkInfo = networkInfos[name]
		createMethod(name, networkInfo, remote)
		remote.OnClientEvent:Connect(function(id, ...)
			local args = { ... }
			local guards = clientEvents[name]
			if not guards then
				return nil
			end
			if not config.disableClientGuards then
				local paramGuards = guards[1][1]
				local restGuard = guards[1][2]
				do
					local i = 0
					local _shouldIncrement = false
					while true do
						if _shouldIncrement then
							i += 1
						else
							_shouldIncrement = true
						end
						if not (i < math.max(#paramGuards, #args)) then
							break
						end
						local guard = paramGuards[i + 1] or restGuard
						if guard and not guard(args[i + 1]) then
							if config.warnOnInvalidGuards then
								warn("Server sent invalid argument for event '" .. (name .. ("' (arg #" .. (tostring(i) .. "):"))), args[i + 1])
							end
							fireNetworkHandler("onBadRequest", Players.LocalPlayer, networkInfo, i)
							return remote:FireServer(id, NetworkingFunctionError.BadRequest)
						end
					end
				end
			end
			local processor = processors[name]
			if processor then
				local result = processor(nil, unpack(args))
				local _arg0 = function(value)
					return remote:FireServer(id, getProcessResult(value), value)
				end
				result:andThen(_arg0):catch(function(reason)
					warn("Failed to process request to " .. name)
					warn(reason)
					remote:FireServer(id, false)
				end)
			else
				remote:FireServer(id, false)
			end
		end)
	end
	return handler
end
local timeoutPromise
function createClientMethod(guard, middleware, processors, networkInfo, requestInfo, name, remote, config)
	local method = {
		invoke = function(self, ...)
			local args = { ... }
			return self:invokeWithTimeout(config.defaultClientTimeout, unpack(args))
		end,
		invokeWithTimeout = function(self, timeout, ...)
			local args = { ... }
			return TS.Promise.race({ timeoutPromise(timeout, NetworkingFunctionError.Timeout), TS.Promise.new(function(resolve, reject, onCancel)
				local _original = requestInfo.nextId
				requestInfo.nextId += 1
				local id = _original
				local _requests = requestInfo.requests
				local _arg1 = function(value, rejection)
					if rejection then
						return reject(rejection)
					end
					if not config.disableClientGuards and not guard(value) then
						if config.warnOnInvalidGuards then
							warn("Server returned invalid value from event '" .. (name .. "':"), value)
						end
						fireNetworkHandler("onBadResponse", Players.LocalPlayer, networkInfo)
						return reject(NetworkingFunctionError.InvalidResult)
					end
					resolve(value)
				end
				_requests[id] = _arg1
				onCancel(function()
					requestInfo.requests[id] = nil
				end)
				remote:FireServer(id, unpack(args))
			end) })
		end,
		setCallback = function(self, callback)
			local _processors = processors
			local _name = name
			if _processors[_name] ~= nil then
				warn("Function.setCallback was called multiple times for " .. name)
			end
			local processor = createMiddlewareProcessor(middleware, networkInfo, function(_, ...)
				local args = { ... }
				return callback(unpack(args))
			end)
			local _processors_1 = processors
			local _name_1 = name
			_processors_1[_name_1] = processor
		end,
		predict = function(self, ...)
			local args = { ... }
			return TS.Promise.new(function(resolve, reject)
				local _processors = processors
				local _name = name
				local processor = _processors[_name]
				if not processor then
					return reject(NetworkingFunctionError.Unprocessed)
				end
				resolve(processor(nil, unpack(args)))
			end)
		end,
	}
	setmetatable(method, {
		__call = function(method, ...)
			local args = { ... }
			return method:invoke(unpack(args))
		end,
	})
	return method
end
function timeoutPromise(timeout, rejectValue)
	local _exp = TS.Promise.delay(timeout)
	local _arg0 = function()
		return TS.Promise.reject(rejectValue)
	end
	return _exp:andThen(_arg0)
end
function getProcessResult(value)
	return if value == Skip then NetworkingFunctionError.Cancelled else true
end
return {
	createClientHandler = createClientHandler,
}
