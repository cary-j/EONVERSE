-- Compiled with roblox-ts v2.1.0
local TS = _G[script]
local Players = TS.import(script, TS.getModule(script, "@rbxts", "services")).Players
local t = TS.import(script, TS.getModule(script, "@rbxts", "t").lib.ts).t
local _errors = TS.import(script, script.Parent, "errors")
local getFunctionError = _errors.getFunctionError
local NetworkingFunctionError = _errors.NetworkingFunctionError
local createMiddlewareProcessor = TS.import(script, script.Parent.Parent, "middleware", "createMiddlewareProcessor").createMiddlewareProcessor
local Skip = TS.import(script, script.Parent.Parent, "middleware", "skip").Skip
local fireNetworkHandler = TS.import(script, script.Parent.Parent, "handlers").fireNetworkHandler
local createServerMethod, getRequestInfo, getProcessResult
local function createServerHandler(serverRemotes, clientRemotes, networkInfos, serverEvents, clientEvents, config, middlewareFactoryList)
	local handler = {}
	local processors = {}
	local players = {}
	local function createMethod(name, networkInfo, remote)
		if handler[name] ~= nil then
			return nil
		end
		local _exp = (serverEvents[name] or clientEvents[name])[2]
		local _result = middlewareFactoryList
		if _result ~= nil then
			_result = _result[name]
		end
		local _condition = _result
		if _condition == nil then
			_condition = {}
		end
		handler[name] = createServerMethod(_exp, _condition, processors, networkInfo, players, name, remote, config)
	end
	for alias, remote in clientRemotes do
		-- create server method
		local name = string.sub(alias, 3)
		local networkInfo = networkInfos[name]
		createMethod(name, networkInfo, remote)
		remote.OnServerEvent:Connect(function(player, id, processResult, result)
			if not t.number(id) then
				return nil
			end
			local requestInfo = getRequestInfo(player, players)
			local _requests = requestInfo.requests
			local _id = id
			local request = _requests[_id]
			local _requests_1 = requestInfo.requests
			local _id_1 = id
			_requests_1[_id_1] = nil
			if request then
				request(result, getFunctionError(processResult))
			end
		end)
	end
	for alias, remote in serverRemotes do
		-- invoke callback
		local name = string.sub(alias, 3)
		local networkInfo = networkInfos[name]
		createMethod(name, networkInfo, remote)
		remote.OnServerEvent:Connect(function(player, id, ...)
			local args = { ... }
			local guards = serverEvents[name]
			if not guards then
				return nil
			end
			if not config.disableServerGuards then
				local paramGuards = guards[1][1]
				local restGuard = guards[1][2]
				do
					local i = 0
					local _shouldIncrement = false
					while true do
						if _shouldIncrement then
							i += 1
						else
							_shouldIncrement = true
						end
						if not (i < math.max(#paramGuards, #args)) then
							break
						end
						local guard = paramGuards[i + 1] or restGuard
						if guard and not guard(args[i + 1]) then
							if config.warnOnInvalidGuards then
								warn("'" .. (tostring(player) .. ("' sent invalid arguments for event '" .. (name .. ("' (arg #" .. (tostring(i) .. "):"))))), args[i + 1])
							end
							fireNetworkHandler("onBadRequest", player, networkInfo, i)
							return remote:FireClient(player, id, NetworkingFunctionError.BadRequest)
						end
					end
				end
			end
			local processor = processors[name]
			if processor then
				local result = processor(player, unpack(args))
				local _arg0 = function(value)
					return remote:FireClient(player, id, getProcessResult(value), value)
				end
				result:andThen(_arg0):catch(function(reason)
					warn("Failed to process request to " .. name)
					warn(reason)
					remote:FireClient(player, id, false)
				end)
			else
				remote:FireClient(player, id, false)
			end
		end)
	end
	Players.PlayerRemoving:Connect(function(player)
		local _player = player
		players[_player] = nil
	end)
	return handler
end
local timeoutPromise
function createServerMethod(guard, middleware, processors, networkInfo, players, name, remote, config)
	local method = {
		invoke = function(self, player, ...)
			local args = { ... }
			return self:invokeWithTimeout(player, config.defaultServerTimeout, unpack(args))
		end,
		invokeWithTimeout = function(self, player, timeout, ...)
			local args = { ... }
			return TS.Promise.race({ timeoutPromise(timeout, NetworkingFunctionError.Timeout), TS.Promise.new(function(resolve, reject, onCancel)
				local requestInfo = getRequestInfo(player, players)
				local _original = requestInfo.nextId
				requestInfo.nextId += 1
				local id = _original
				local _requests = requestInfo.requests
				local _arg1 = function(value, rejection)
					if rejection then
						return reject(rejection)
					end
					if not config.disableServerGuards and not guard(value) then
						if config.warnOnInvalidGuards then
							warn("'" .. (tostring(player) .. ("' returned invalid value from event '" .. (name .. "':"))), value)
						end
						fireNetworkHandler("onBadResponse", player, networkInfo)
						return reject(NetworkingFunctionError.InvalidResult)
					end
					resolve(value)
				end
				_requests[id] = _arg1
				onCancel(function()
					requestInfo.requests[id] = nil
				end)
				remote:FireClient(player, id, unpack(args))
			end) })
		end,
		setCallback = function(self, callback)
			local _processors = processors
			local _name = name
			if _processors[_name] ~= nil then
				warn("Function.setCallback was called multiple times for " .. name)
			end
			local processor = createMiddlewareProcessor(middleware, networkInfo, callback)
			local _processors_1 = processors
			local _name_1 = name
			_processors_1[_name_1] = processor
		end,
		predict = function(self, player, ...)
			local args = { ... }
			return TS.Promise.new(function(resolve, reject)
				local _processors = processors
				local _name = name
				local processor = _processors[_name]
				if not processor then
					return reject(NetworkingFunctionError.Unprocessed)
				end
				resolve(processor(player, unpack(args)))
			end)
		end,
	}
	setmetatable(method, {
		__call = function(method, player, ...)
			local args = { ... }
			return method:invoke(player, unpack(args))
		end,
	})
	return method
end
function getRequestInfo(player, map)
	local _map = map
	local _player = player
	local requestInfo = _map[_player]
	if requestInfo then
		return requestInfo
	end
	requestInfo = {
		nextId = 0,
		requests = {},
	}
	local _map_1 = map
	local _player_1 = player
	local _requestInfo = requestInfo
	_map_1[_player_1] = _requestInfo
	return requestInfo
end
function timeoutPromise(timeout, rejectValue)
	local _exp = TS.Promise.delay(timeout)
	local _arg0 = function()
		return TS.Promise.reject(rejectValue)
	end
	return _exp:andThen(_arg0)
end
function getProcessResult(value)
	return if value == Skip then NetworkingFunctionError.Cancelled else true
end
return {
	createServerHandler = createServerHandler,
}
