-- Compiled with roblox-ts v2.1.0
local TS = _G[script]
local Object = TS.import(script, TS.getModule(script, "@rbxts", "object-utils"))
local RunService = TS.import(script, TS.getModule(script, "@rbxts", "services")).RunService
local populateInstanceMap = TS.import(script, script.Parent.Parent, "util", "populateInstanceMap").populateInstanceMap
local createClientHandler = TS.import(script, script.Parent, "createClientHandler").createClientHandler
local createServerHandler = TS.import(script, script.Parent, "createServerHandler").createServerHandler
local function getDefaultConfiguration(config)
	local _object = {}
	local _left = "disableClientGuards"
	local _condition = config.disableClientGuards
	if _condition == nil then
		_condition = false
	end
	_object[_left] = _condition
	local _left_1 = "disableServerGuards"
	local _condition_1 = config.disableServerGuards
	if _condition_1 == nil then
		_condition_1 = false
	end
	_object[_left_1] = _condition_1
	local _left_2 = "defaultClientTimeout"
	local _condition_2 = config.defaultClientTimeout
	if _condition_2 == nil then
		_condition_2 = 30
	end
	_object[_left_2] = _condition_2
	local _left_3 = "defaultServerTimeout"
	local _condition_3 = config.defaultServerTimeout
	if _condition_3 == nil then
		_condition_3 = 10
	end
	_object[_left_3] = _condition_3
	local _left_4 = "warnOnInvalidGuards"
	local _condition_4 = config.warnOnInvalidGuards
	if _condition_4 == nil then
		_condition_4 = RunService:IsStudio()
	end
	_object[_left_4] = _condition_4
	return _object
end
local function createNetworkingFunction(globalName, serverEvents, clientEvents, serverMiddleware, clientMiddleware, partialConfig)
	if partialConfig == nil then
		partialConfig = {}
	end
	local config = getDefaultConfiguration(partialConfig)
	local networkInfos = {}
	local serverRemotes = {}
	local clientRemotes = {}
	local _exp = Object.keys(serverEvents)
	local _arg0 = function(x)
		return "s:" .. tostring(x)
	end
	-- ▼ ReadonlyArray.map ▼
	local _newValue = table.create(#_exp)
	for _k, _v in _exp do
		_newValue[_k] = _arg0(_v, _k - 1, _exp)
	end
	-- ▲ ReadonlyArray.map ▲
	local serverNames = _newValue
	local _exp_1 = Object.keys(clientEvents)
	local _arg0_1 = function(x)
		return "c:" .. tostring(x)
	end
	-- ▼ ReadonlyArray.map ▼
	local _newValue_1 = table.create(#_exp_1)
	for _k, _v in _exp_1 do
		_newValue_1[_k] = _arg0_1(_v, _k - 1, _exp_1)
	end
	-- ▲ ReadonlyArray.map ▲
	local clientNames = _newValue_1
	populateInstanceMap("RemoteEvent", "functions-" .. globalName, serverNames, serverRemotes)
	populateInstanceMap("RemoteEvent", "functions-" .. globalName, clientNames, clientRemotes)
	for alias in serverRemotes do
		local name = string.sub(alias, 3)
		local _arg1 = {
			eventType = "Function",
			globalName = globalName,
			name = name,
		}
		networkInfos[name] = _arg1
	end
	for alias in clientRemotes do
		local name = string.sub(alias, 3)
		local _arg1 = {
			eventType = "Function",
			globalName = globalName,
			name = name,
		}
		networkInfos[name] = _arg1
	end
	if RunService:IsServer() then
		return {
			server = createServerHandler(serverRemotes, clientRemotes, networkInfos, serverEvents, clientEvents, config, serverMiddleware),
			client = nil,
		}
	else
		return {
			server = nil,
			client = createClientHandler(serverRemotes, clientRemotes, networkInfos, serverEvents, clientEvents, config, clientMiddleware),
		}
	end
end
return {
	createNetworkingFunction = createNetworkingFunction,
}
